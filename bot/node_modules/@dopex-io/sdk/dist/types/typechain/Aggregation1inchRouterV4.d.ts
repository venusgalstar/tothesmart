import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "./common";
export declare namespace LimitOrderProtocolRFQ {
    type OrderRFQStruct = {
        info: PromiseOrValue<BigNumberish>;
        makerAsset: PromiseOrValue<string>;
        takerAsset: PromiseOrValue<string>;
        maker: PromiseOrValue<string>;
        allowedSender: PromiseOrValue<string>;
        makingAmount: PromiseOrValue<BigNumberish>;
        takingAmount: PromiseOrValue<BigNumberish>;
    };
    type OrderRFQStructOutput = [
        BigNumber,
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber
    ] & {
        info: BigNumber;
        makerAsset: string;
        takerAsset: string;
        maker: string;
        allowedSender: string;
        makingAmount: BigNumber;
        takingAmount: BigNumber;
    };
}
export declare namespace I1inchAggregationRouterV4 {
    type SwapDescriptionStruct = {
        srcToken: PromiseOrValue<string>;
        dstToken: PromiseOrValue<string>;
        srcReceiver: PromiseOrValue<string>;
        dstReceiver: PromiseOrValue<string>;
        amount: PromiseOrValue<BigNumberish>;
        minReturnAmount: PromiseOrValue<BigNumberish>;
        flags: PromiseOrValue<BigNumberish>;
        permit: PromiseOrValue<BytesLike>;
    };
    type SwapDescriptionStructOutput = [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string
    ] & {
        srcToken: string;
        dstToken: string;
        srcReceiver: string;
        dstReceiver: string;
        amount: BigNumber;
        minReturnAmount: BigNumber;
        flags: BigNumber;
        permit: string;
    };
}
export interface Aggregation1inchRouterV4Interface extends utils.Interface {
    functions: {
        "DOMAIN_SEPARATOR()": FunctionFragment;
        "LIMIT_ORDER_RFQ_TYPEHASH()": FunctionFragment;
        "cancelOrderRFQ(uint256)": FunctionFragment;
        "destroy()": FunctionFragment;
        "fillOrderRFQ((uint256,address,address,address,address,uint256,uint256),bytes,uint256,uint256)": FunctionFragment;
        "fillOrderRFQTo((uint256,address,address,address,address,uint256,uint256),bytes,uint256,uint256,address)": FunctionFragment;
        "fillOrderRFQToWithPermit((uint256,address,address,address,address,uint256,uint256),bytes,uint256,uint256,address,bytes)": FunctionFragment;
        "invalidatorForOrderRFQ(address,uint256)": FunctionFragment;
        "owner()": FunctionFragment;
        "renounceOwnership()": FunctionFragment;
        "rescueFunds(address,uint256)": FunctionFragment;
        "swap(address,(address,address,address,address,uint256,uint256,uint256,bytes),bytes)": FunctionFragment;
        "transferOwnership(address)": FunctionFragment;
        "uniswapV3Swap(uint256,uint256,uint256[])": FunctionFragment;
        "uniswapV3SwapCallback(int256,int256,bytes)": FunctionFragment;
        "uniswapV3SwapTo(address,uint256,uint256,uint256[])": FunctionFragment;
        "uniswapV3SwapToWithPermit(address,address,uint256,uint256,uint256[],bytes)": FunctionFragment;
        "unoswap(address,uint256,uint256,bytes32[])": FunctionFragment;
        "unoswapWithPermit(address,uint256,uint256,bytes32[],bytes)": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "DOMAIN_SEPARATOR" | "LIMIT_ORDER_RFQ_TYPEHASH" | "cancelOrderRFQ" | "destroy" | "fillOrderRFQ" | "fillOrderRFQTo" | "fillOrderRFQToWithPermit" | "invalidatorForOrderRFQ" | "owner" | "renounceOwnership" | "rescueFunds" | "swap" | "transferOwnership" | "uniswapV3Swap" | "uniswapV3SwapCallback" | "uniswapV3SwapTo" | "uniswapV3SwapToWithPermit" | "unoswap" | "unoswapWithPermit"): FunctionFragment;
    encodeFunctionData(functionFragment: "DOMAIN_SEPARATOR", values?: undefined): string;
    encodeFunctionData(functionFragment: "LIMIT_ORDER_RFQ_TYPEHASH", values?: undefined): string;
    encodeFunctionData(functionFragment: "cancelOrderRFQ", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "destroy", values?: undefined): string;
    encodeFunctionData(functionFragment: "fillOrderRFQ", values: [
        LimitOrderProtocolRFQ.OrderRFQStruct,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
    ]): string;
    encodeFunctionData(functionFragment: "fillOrderRFQTo", values: [
        LimitOrderProtocolRFQ.OrderRFQStruct,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<string>
    ]): string;
    encodeFunctionData(functionFragment: "fillOrderRFQToWithPermit", values: [
        LimitOrderProtocolRFQ.OrderRFQStruct,
        PromiseOrValue<BytesLike>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "invalidatorForOrderRFQ", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "renounceOwnership", values?: undefined): string;
    encodeFunctionData(functionFragment: "rescueFunds", values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "swap", values: [
        PromiseOrValue<string>,
        I1inchAggregationRouterV4.SwapDescriptionStruct,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "transferOwnership", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "uniswapV3Swap", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>[]
    ]): string;
    encodeFunctionData(functionFragment: "uniswapV3SwapCallback", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "uniswapV3SwapTo", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>[]
    ]): string;
    encodeFunctionData(functionFragment: "uniswapV3SwapToWithPermit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>[],
        PromiseOrValue<BytesLike>
    ]): string;
    encodeFunctionData(functionFragment: "unoswap", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "unoswapWithPermit", values: [
        PromiseOrValue<string>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BytesLike>[],
        PromiseOrValue<BytesLike>
    ]): string;
    decodeFunctionResult(functionFragment: "DOMAIN_SEPARATOR", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "LIMIT_ORDER_RFQ_TYPEHASH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "cancelOrderRFQ", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "destroy", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fillOrderRFQ", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fillOrderRFQTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fillOrderRFQToWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "invalidatorForOrderRFQ", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rescueFunds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "uniswapV3Swap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "uniswapV3SwapCallback", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "uniswapV3SwapTo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "uniswapV3SwapToWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unoswap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unoswapWithPermit", data: BytesLike): Result;
    events: {
        "OrderFilledRFQ(bytes32,uint256)": EventFragment;
        "OwnershipTransferred(address,address)": EventFragment;
        "Swapped(address,address,address,address,uint256,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "OrderFilledRFQ"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Swapped"): EventFragment;
}
export interface OrderFilledRFQEventObject {
    orderHash: string;
    makingAmount: BigNumber;
}
export declare type OrderFilledRFQEvent = TypedEvent<[
    string,
    BigNumber
], OrderFilledRFQEventObject>;
export declare type OrderFilledRFQEventFilter = TypedEventFilter<OrderFilledRFQEvent>;
export interface OwnershipTransferredEventObject {
    previousOwner: string;
    newOwner: string;
}
export declare type OwnershipTransferredEvent = TypedEvent<[
    string,
    string
], OwnershipTransferredEventObject>;
export declare type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;
export interface SwappedEventObject {
    sender: string;
    srcToken: string;
    dstToken: string;
    dstReceiver: string;
    spentAmount: BigNumber;
    returnAmount: BigNumber;
}
export declare type SwappedEvent = TypedEvent<[
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber
], SwappedEventObject>;
export declare type SwappedEventFilter = TypedEventFilter<SwappedEvent>;
export interface Aggregation1inchRouterV4 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: Aggregation1inchRouterV4Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;
        LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;
        cancelOrderRFQ(orderInfo: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        destroy(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        fillOrderRFQ(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        fillOrderRFQTo(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        fillOrderRFQToWithPermit(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        invalidatorForOrderRFQ(maker: PromiseOrValue<string>, slot: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        renounceOwnership(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        rescueFunds(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        swap(caller: PromiseOrValue<string>, desc: I1inchAggregationRouterV4.SwapDescriptionStruct, data: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        uniswapV3Swap(amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        uniswapV3SwapCallback(amount0Delta: PromiseOrValue<BigNumberish>, amount1Delta: PromiseOrValue<BigNumberish>, arg2: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        uniswapV3SwapTo(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        uniswapV3SwapToWithPermit(recipient: PromiseOrValue<string>, srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unoswap(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        unoswapWithPermit(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
    LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<string>;
    cancelOrderRFQ(orderInfo: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    destroy(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    fillOrderRFQ(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    fillOrderRFQTo(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    fillOrderRFQToWithPermit(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    invalidatorForOrderRFQ(maker: PromiseOrValue<string>, slot: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
    owner(overrides?: CallOverrides): Promise<string>;
    renounceOwnership(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    rescueFunds(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    swap(caller: PromiseOrValue<string>, desc: I1inchAggregationRouterV4.SwapDescriptionStruct, data: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    uniswapV3Swap(amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    uniswapV3SwapCallback(amount0Delta: PromiseOrValue<BigNumberish>, amount1Delta: PromiseOrValue<BigNumberish>, arg2: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    uniswapV3SwapTo(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    uniswapV3SwapToWithPermit(recipient: PromiseOrValue<string>, srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unoswap(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    unoswapWithPermit(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;
        LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<string>;
        cancelOrderRFQ(orderInfo: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        destroy(overrides?: CallOverrides): Promise<void>;
        fillOrderRFQ(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;
        fillOrderRFQTo(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;
        fillOrderRFQToWithPermit(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, permit: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber, BigNumber]>;
        invalidatorForOrderRFQ(maker: PromiseOrValue<string>, slot: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<string>;
        renounceOwnership(overrides?: CallOverrides): Promise<void>;
        rescueFunds(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
        swap(caller: PromiseOrValue<string>, desc: I1inchAggregationRouterV4.SwapDescriptionStruct, data: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            returnAmount: BigNumber;
            gasLeft: BigNumber;
        }>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        uniswapV3Swap(amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber>;
        uniswapV3SwapCallback(amount0Delta: PromiseOrValue<BigNumberish>, amount1Delta: PromiseOrValue<BigNumberish>, arg2: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<void>;
        uniswapV3SwapTo(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: CallOverrides): Promise<BigNumber>;
        uniswapV3SwapToWithPermit(recipient: PromiseOrValue<string>, srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], permit: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
        unoswap(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<BigNumber>;
        unoswapWithPermit(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], permit: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "OrderFilledRFQ(bytes32,uint256)"(orderHash?: null, makingAmount?: null): OrderFilledRFQEventFilter;
        OrderFilledRFQ(orderHash?: null, makingAmount?: null): OrderFilledRFQEventFilter;
        "OwnershipTransferred(address,address)"(previousOwner?: PromiseOrValue<string> | null, newOwner?: PromiseOrValue<string> | null): OwnershipTransferredEventFilter;
        OwnershipTransferred(previousOwner?: PromiseOrValue<string> | null, newOwner?: PromiseOrValue<string> | null): OwnershipTransferredEventFilter;
        "Swapped(address,address,address,address,uint256,uint256)"(sender?: null, srcToken?: null, dstToken?: null, dstReceiver?: null, spentAmount?: null, returnAmount?: null): SwappedEventFilter;
        Swapped(sender?: null, srcToken?: null, dstToken?: null, dstReceiver?: null, spentAmount?: null, returnAmount?: null): SwappedEventFilter;
    };
    estimateGas: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;
        LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;
        cancelOrderRFQ(orderInfo: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        destroy(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        fillOrderRFQ(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        fillOrderRFQTo(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        fillOrderRFQToWithPermit(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        invalidatorForOrderRFQ(maker: PromiseOrValue<string>, slot: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        renounceOwnership(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        rescueFunds(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        swap(caller: PromiseOrValue<string>, desc: I1inchAggregationRouterV4.SwapDescriptionStruct, data: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        uniswapV3Swap(amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        uniswapV3SwapCallback(amount0Delta: PromiseOrValue<BigNumberish>, amount1Delta: PromiseOrValue<BigNumberish>, arg2: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        uniswapV3SwapTo(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        uniswapV3SwapToWithPermit(recipient: PromiseOrValue<string>, srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        unoswap(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        unoswapWithPermit(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        LIMIT_ORDER_RFQ_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        cancelOrderRFQ(orderInfo: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        destroy(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        fillOrderRFQ(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        fillOrderRFQTo(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        fillOrderRFQToWithPermit(order: LimitOrderProtocolRFQ.OrderRFQStruct, signature: PromiseOrValue<BytesLike>, makingAmount: PromiseOrValue<BigNumberish>, takingAmount: PromiseOrValue<BigNumberish>, target: PromiseOrValue<string>, permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        invalidatorForOrderRFQ(maker: PromiseOrValue<string>, slot: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        renounceOwnership(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        rescueFunds(token: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        swap(caller: PromiseOrValue<string>, desc: I1inchAggregationRouterV4.SwapDescriptionStruct, data: PromiseOrValue<BytesLike>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        transferOwnership(newOwner: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        uniswapV3Swap(amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        uniswapV3SwapCallback(amount0Delta: PromiseOrValue<BigNumberish>, amount1Delta: PromiseOrValue<BigNumberish>, arg2: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        uniswapV3SwapTo(recipient: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        uniswapV3SwapToWithPermit(recipient: PromiseOrValue<string>, srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BigNumberish>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unoswap(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        unoswapWithPermit(srcToken: PromiseOrValue<string>, amount: PromiseOrValue<BigNumberish>, minReturn: PromiseOrValue<BigNumberish>, pools: PromiseOrValue<BytesLike>[], permit: PromiseOrValue<BytesLike>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
